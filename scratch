[[punctuation,'('],[identifier,postfix],[number,1],[identifier,sub],[punctuation,'('],[number,1],[punctuation,')'],[punctuation,')'],[punctuation,eof]]

(postfix 1 sub (1)) eof

[[punctuation,'('],[identifier,postfix],[number,1],[punctuation,'('],[number,1],[punctuation,')'],[punctuation,')'],[punctuation,eof]]

(postfix 1 (1))

[[punctuation,'('],[identifier,postfix],[number,1],[number,4],[identifier,sub],[punctuation,'('],[number,3],[number,4],[identifier,sub],[punctuation,')'],[identifier,exec],[number,3],[punctuation,')'],[punctuation,eof]]

(postfix 1 4 sub (3 4 sub) exec 3)


(postfix 1 4 sub (3 4 sub) exec 3)

(postfix 1 1 nget 0 lt (0 swap sub) () sel exec).


Calls to interpret:

interpret([0,5,2,lt],[]).
interpret([0,5,2,gt],[]).
interpret([0,5,2,eq],[]).

interpret([2,3,nget],[4,5]).  --> fail
interpret([2,2,nget],[4,5]).  --> 5
interpret([2,0,nget],[4,5]).  --> fail
interpret([0,nget],[]). --> fail

interpret([0,[3,2,1],exec],[]). --> 1


interpret([2, swap],[3,4]).

interpret([3, sel],[1,2,0]).

interpret([1,4,sub,[3,4,[swap],sub],exec,3],[5]).

interpret([0,1,2,add],[]).

interpret([2,exec],[[3,2,1], 3]). 
	exec | [3,2,1] 3
	3 2 1 | 3
	  2 1 | 3 3
	    1 | 2 3 3
	      | 1 2 3 3


interpret([1,1,nget,0,lt,[0,swap,sub],[],sel,exec],[-7]).


% rem
execute_command([Command|Rest], Stack1, Result) :- (Command == rem),
	pop(Stack1,Val1,Stack2),
	number(Val1),
	pop(Stack2,Val2,Stack3),
	number(Val2),
	is(Remainder, Val2 rem Val1),
	push(Stack3, Remainder, Stack4),
	process_commands(Rest, Stack4, Result).



// Testing sel
(postfix 1 2 3 sel). -[17]-> 2
interpret([1,2,3,sel],[17]).


	// Empty command sequnces

	(postfix 1 1 nget 0 lt (0 swap sub) () sel exec). -->

	interpret([1,1,nget,0,lt,[0,swap,sub],[0],sel,exec],[-7]).

interpret([1,[],exec],[1]).	


